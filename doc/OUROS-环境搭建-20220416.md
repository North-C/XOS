# OUROS-环境搭建

在开始学习和编写内核源代码之前，配置一个简单的系统运行环境。

## QEMU安装

我使用的是运行在vmware中的虚拟机Ubuntu18.04，运行以下命令即可安装QEMU：

```
sudo apt-get install qemu
```

qemu有两种用途：

- User mode emulation：即用户模式，在QEMU模拟的CPU上启动程序。

- System emulation（常用）：提供一个完整机器的虚拟模型来运行客户操作系统。此模式下，CPU可以是模拟的，也可以通过KVM等使用宿主机的CPU。

常用选项参数：

```
qemu-system-i386             # 模拟的CPU架构
-name                      # 虚拟机名称

# 机型，VMWareIO端口仿真，在核心转储中包含来宾内存，内存合并支持，ACPI异构内存属性表，USB设备,内存 
-machine q35,vmport=off,dump-guest-core=off,mem-merge=off,hmat=on,usb=off,memory-backend=pc.ram  

-m 512M    #内存，可以使用M和G作为后缀

-serial dev # 将虚拟串行端口重定向到主机字符设备 dev。默认设备vc处于图形模式和                    stdio非图形模式。
-serial none # 用于禁用所有串行端口
常见设备： 
stdio 标准输入/输出
pipe:filename 命名管道文件名
null 无效装置
...

-hda file
-hdb file
-hdc file
-hdd file
# 将文件用作硬盘 0、1、2 或 3 映像（请参阅系统仿真用户指南中的磁盘映像 章节）

#模拟电路板上带有n个CPU的 SMP 系统 
-smp cpus=8,cores=4,sockets=2,threads=1                #核心，插槽，线程；sockets, cores, die, threads 的乘积必须等于最大 CPU 数量
-smp 16,sockets=2,clusters=2,cores=2,threads=2,maxcpus=16

-S:表示qemu虚拟机冻结cpu，直到gdb输入相应控制命令
-s:表示在1234端口接受gdb调试连接
```

> 更多选项和参数可以查看手册：https://www.qemu.org/docs/master/

gdb远程调试实例：

```sh
qemu-system-i386 -s -S boot.bin   

# 另一个终端中进入gdb
gdb
(gdb) target remote localhost:1234
```

## 磁盘镜像与GRUB

### 创建磁盘镜像

```c
qemu-img create ./hda.img 2g
# 或者dd创建
dd if=/dev/zero of=./hda.img bs=512 count=204800
```

### 格式化虚拟硬盘

```sh
sudo losetup /dev/loop17 hda.img      # 设置回环设备

sudo mkfs.ext2 -q /dev/loop17    # 建立ext2文件系统

sudo mkdir ./hdisk/       # 创建挂载目录

sudo mount -o loop ./hda.img ./hdisk   # 挂载硬盘镜像至hdisk目录下，-o 指定挂载设备类型

sudo mkdir ./hdisk/boot/             # 建立boot目录
```

`losetup`设置循环设备时，出现错误：

```
losetup: ./hda.img: failed to set up loop device: Device or resource busy
```

解决： 通过`df -h` 或 `losetup -f` 查看 `Filesystem`列，寻找没有用到的`/dev/loopx`，中间没有剩余，则从下一个开始使用。

例如：出现的最大的是`/dev/loop16`，则使用`/dev/loop17`进行挂载。

mount 失败时，可以查看或卸载：

```sh
mount | grep "/home/you/dir"
# 卸载1
umount /home/you/dir 
# 卸载2
losetup -a | grep example.img
umount /dev/loop<N>
```

* 循环设备(loop device)：
  
  * `/dev/loop`(或者 `vnd` , `lofi`)，是一种伪设备(pesudo)，其作用在与**使得文件可以如同块设备一般被访问。**
    在使用之前，loop 设备需要与现存文件系统上的文件相关联，这样的关联提供给用户一个API，使得将文件视为块特殊文件使用。如果文件中包含一个完整的文件系统，那么这个文件就能如同磁盘设备一般被挂载，文件内容就会出现在被挂载的目录当中。
    
    通常用于<u>光盘</u>或者<u>磁盘镜像</u>，使其摆脱底层驱动设备以实现文件访问。
    
    在Linux当中，设备名按照<u>相应设备驱动程序的符号表项</u>进行命名，设备节点通常叫做：`/dev/loop0`等。
  
  * 需要注意的是，loop device通常和 [loopback device](https://zh.wikipedia.org/wiki/%E5%9B%9E%E7%8E%AF) --- 即回环设备混淆，后者是专门用于网络的术语。
  
  * 具体创建方式： 静态的设备目录 --- `makedev`，动态的设备目录 --- 设备文件系统或使用 `mknod`，管理界面 --- `losetup`
  
  * losetup使用范例：
    
    ```sh
    dd if=/dev/zero of=/file bs=1k count=100
    losetup -e des /dev/loop0 /file        # -e 选择编码方式，默认不编码
    Password:
    Init (up to 16 hex digits):
    mkfs -t ext2 /dev/loop0 100
    mount -t ext2 /dev/loop0 /mnt
    ...
    umount /dev/loop0
    losetup -d /dev/loop0         # 取消关联
    ```

---

### Grub安装

```sh
sudo grub-install --boot-directory=./hdisk/boot/ --force --allow-floppy /dev/loop17
```

* `--boot-directory` 指向先前我们在虚拟硬盘中建立的boot目录。
* `--force --allow-floppy` ：指向我们的虚拟硬盘设备文件/dev/loop17。

在 /hdisk/boot/ 目录下多了一个 grub 目录，表示我们的 GRUB 安装成功。

在 /hdisk/boot/grub/ 目录下建立一个 grub.cfg 文本文件，GRUB 正是通过这个文件内容，查找到我们的操作系统映像文件的。

> 在CentOS一系列的系统当中，grub-install 命令格式为 grub2-install

### Grub配置

> Grub2.0官方手册：https://www.gnu.org/software/grub/manual/grub/grub.html#Multi_002dboot-manual-config%20GRUB2%20%E6%89%8B%E5%86%8C
> 
> grub2详解（查阅命令等）：https://www.cnblogs.com/f-ck-need-u/p/7094693.html#auto_id_10

grub.cfg配置如下：

```sh
menuentry 'MyOS' {
insmod part_msdos         
insmod ext2
set root='hd0'         
multiboot /boot/kernel.bin #加载boot目录下的kernel.bin文件 因为我用的multiboot的
      #引导规范所以这里的命令是multiboot #/boot/kernel.bin;如果用multiboot2的规范，那么就将multiboot改成multiboot2
boot #引导启动
}
set timeout_style=menu
if [ "${timeout}" = 0 ]; then
  set timeout=10 #等待10秒钟自动启动
fi
```

---

常用命令：

* 菜单项命令 :
  `menuentry title [--class=class …] [--users=users] [--unrestricted] [--hotkey=key] [--id=id] { command; … }`
  
  定义一个名为title的grub菜单项，当开机时选中该菜单项时，grub会将环境变量chosen的值赋给 --id，执行一系列command命令。如果命令执行成功且内核被加载，那么将会执行boot命令。
  
  `--class`可以使用任意次数来将菜单条目分组到类中。
  `--user`授予特定用户访问特定菜单条目的权限。
  `--unrestricted`授予所有用户访问特定菜单条目的权限。
  `--hotkey`将热键与菜单条目相关联。
  `--id` 用于将唯一标识符与菜单条目相关联。 

* `inmod module`  插入名为module的动态 GRUB 模块。

* `search [--file|--label|--fs-uuid] [--set [var]] [--no-floppy] [--hint args] name` ：通过文件[--file]、卷标[--label]、文件系统UUID[--fs-uuid]来搜索设备。
  
  * 如果使用了"--set"选项，则会将第一个找到的设备设置为环境变量"var"的值，默认的变量"var"为'root'。

* `set [envvar=value]`  将环境变量envvar设置为value。如果不带参数调用，则打印所有环境变量及其值。

* `unset envvar` 取消设置环境变量envvar。

常用内置变量：

* chosen 变量 ：
  * 当开机时选中某个菜单项启动时，该菜单的title将被赋值给chosen变量。该变量一般只用于引用，而不用于修改。
* cmdpath 变量
  * grub2加载的core.img的目录路径，是绝对路径，即包括了设备名的路径，如(hd0,gpt1)/boot/grub2/。该变量值不应该修改。
* default 变量
  * 指定默认的菜单项，一般其后都会跟随timeout变量。
* timeout 变量
  * 设置菜单等待超时时间，设置为0时将直接启动默认菜单项而不显示菜单，设置为"-1"时将永久等待手动选择。
* fallback 变量
  * 当默认菜单项启动失败，则使用该变量指定的菜单项启动，指定方式同default，可使用数值(从0开始计算)、title或id指定。
* grub_platform 变量
  * 指定该平台是"pc"还是"efi"，pc表示的就是传统的bios平台。
* prefix 变量
  * 在grub启动的时候，grub自动将/boot/grub2目录的绝对路径赋值给该变量，使得以后可以直接从该变量所代表的目录下加载各文件或模块。
* root 变量
  * 该变量指定根设备的名称，使得后续使用从"/"开始的相对路径引用文件时将从该root变量指定的路径开始。一般该变量是grub启动的时候由grub根据prefix变量设置而来的。

```
# 设置一些全局环境变量
set default=0
set fallback=1
set timeout=3

# 将可能使用到的模块一次性装载完
# 支持msdos的模块
insmod part_msdos
# 支持各种文件系统的模块
insmod exfat
insmod ext2
insmod xfs
insmod fat
insmod iso9660

# 定义菜单
menuentry 'CentOS 7' --unrestricted {
        search --no-floppy --fs-uuid --set=root 367d6a77-033b-4037-bbcb-416705ead095
        linux16 /vmlinuz-3.10.0-327.el7.x86_64 root=UUID=b2a70faf-aea4-4d8e-8be8-c7109ac9c8b8 ro biosdevname=0 net.ifnames=0 quiet
        initrd16 /initramfs-3.10.0-327.el7.x86_64.img
}
menuentry 'CentOS 6' --unrestricted {
        search --no-floppy --fs-uuid --set=root f5d8939c-4a04-4f47-a1bc-1b8cbabc4d32
        linux16 /vmlinuz-2.6.32-504.el6.x86_64 root=UUID=edb1bf15-9590-4195-aa11-6dac45c7f6f3 ro quiet
        initrd16 /initramfs-2.6.32-504.el6.x86_64.img
}
```

---

每次开机时执行挂载命令：

```sh
mount hda.img ./hdisk
```

## 成功启动

写好内核，编译成kernel.bin,放进./hdisk/boot，然后调用：  

    qemu-system-i386 ./hd.img

即可运行。

## 开发环境

> 官方文档：https://cmake.org/cmake/help/latest/guide/tutorial/index.html
> 
> vscode与cmake配合：https://zhuanlan.zhihu.com/p/144376188

创建CMakeLists.txt（大小写可以混用）:

```cmake
cmake_minimum_required(VERSION 3.10)

# set the project name
project(Tutorial)
# 可以设置项目版本
# project(Tutorial VERSION 1.0)

# add the executable
add_executable(Tutorial tutorial.cxx)
```

tutorial.cxx为源代码等。

**Build**

```sh
cd build
cmake --build .
```

**Add a Library**

```cmake
# 在库文件MathFunctions目录下的CMakeLists.txt
add_library(MathFunctions mysqrt.cxx)

# 在顶层的 CMakeLists.txt当中

# add the MathFunctions library
add_subdirectory(MathFunctions)
# add the executable
add_executable(Tutorial tutorial.cxx)
target_link_libraries(Tutorial PUBLIC MathFunctions)
# add the binary tree to the search path for include files
# so that we will find TutorialConfig.h
target_include_directories(Tutorial PUBLIC
                          "${PROJECT_BINARY_DIR}"
                      "${PROJECT_SOURCE_DIR}/MathFunctions"
                          )
```

指定CMAKE的标准：

```cmake
# specify the C++ standard
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)
```

添加include的头文件目录：

```
include_directories(header)
```

添加可执行文件：

```
add_executable(Tutorial tutorial.cxx)
```

### VScode配置cmake

安装扩展插件:

* C/C++ : 提供c++调试功能和一些智能提示
* CMake : 提供CMake支持
* CMake Tools : 拓展CMake功能

创建项目后，CMake的插件会显示在vscode的左下角状态栏，没有的话，重启解决一切。

点击并选择kit 工具包，即对应的GCC编译器，之后会生成一个build目录。

在项目根目录下，新建一个CMakeLists.txt配置文件，写完后保存的同时就会自动执行makefile过程，没有自动执行就点击左侧的CMake插件，手动执行。

### GDB

好用的gdb插件，方便安装，信息丰富`gef` ：https://github.com/hugsy/gef

