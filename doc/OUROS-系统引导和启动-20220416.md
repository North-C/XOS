# 系统引导与初始化过程

## 第一条指令
> 参考： https://www.binss.me/blog/boot-process-of-linux-grub/

   一般来说，在接通电源时，主板就已经部分通电了。其处于 Standby 模式，检测是否需要开机。当用户按下电源开关(开机键)后，电源开始进入正常工作模式，它会给主板上电，按照时序供应 5V 和 12V 电源，然后输出 Power_OK 信号，通知主板可以正式工作。最后，主板会向 CPU 的 reset 引脚发送信号，于是CPU将清除所有寄存器中的数据并加载为预设值，根据 Intel SDM vol3 Table 9-1，寄存器值为：

![image-20220417150519908](C:\Users\刘雨晴\AppData\Roaming\Typora\typora-user-images\image-20220417150519908.png)

其中：
```text
EIP          0000FFF0H
CS Selector  F000H
CS base      FFFF0000H
CS Limit     FFFFH
```

可以发现此时 CS 为 0xf000 ， IP 为 0xfff0 。根据 real mode 下地址的计算方法，此时 CS base 应该等于 0xf000 << 4 = 0xf0000 。但为何 Intel SDM 中说它是 0xffff0000 呢？根据 Intel SDM vol3 9.1.4 First Instruction Executed ：

> 段寄存器有一个隐藏的base address部分(不属于寄存器，而是位于一片非一致性cache中)，在 reset 的时候被设置成 0xffff0000 。因此我们需要使用的是这个隐藏的 base address 而不是我们计算得到的 0f0000。
>
> 因此实际上执行的第一条指令的地址为 0xffff0000 + 0xfff0 = 0xfffffff0

## 内存布局

1981年IBM PC机刚推出时系统只带有**640KB**的RAM主存储器（简称内存）。由于所采用的8088/8086 CPU只有20根地址线，因此内存寻址范围最高为1024KB(1MB)。

目前的计算机通常都配置有512MB或者更多的物理内存容量， 并且都采用Intel 32位CPU，即都是PC/AT计算机。因此CPU的物理内存寻址范围已经高达4GB（通过采用CPU的新特性，系统甚至可以寻址64GB的物理内存容量）。

为了与原来的PC机在软件上兼容，系统1MB以下物理内存使用分配上任然保持与原来的PC机基本一致，只是**原来系统ROM中的基本输入输出程序BIOS一直处于CPU能寻址的内存最高端位置处， 而BIOS原来所在的位置将在计算机开机初始化时被用作BIOS的影子（Shadow）区域，即BIOS代码任然会被复制到这个区域中。**

根据 IBM PC compatible PC 规定的内存布局：

```text
+------------------+  <- 0xFFFFFFFF (4GB)
|      32-bit      |
|  memory mapped   |
|     devices      |
|                  |
/\/\/\/\/\/\/\/\/\/\

/\/\/\/\/\/\/\/\/\/\
|                  |
|      Unused      |
|                  |
+------------------+  <- depends on amount of RAM
|                  |
|                  |
| Extended Memory  |
|                  |
|                  |
+------------------+  <- 0x00100000 (1MB)
|     BIOS ROM     |
+------------------+  <- 0x000F0000 (960KB)
|  16-bit devices, |
|  expansion ROMs  |
+------------------+  <- 0x000C0000 (768KB)
|   VGA Display    |
+------------------+  <- 0x000A0000 (640KB)
|                  |
|    Low Memory    |
|                  |
+------------------+  <- 0x00000000
```
<img src="https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/i386%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="image-20220418105932415" style="zoom:50%;" />

可以发现起始阶段的内存地址空间主要在于前 1MB，其中 Low Memory (0-640KB) 为起始阶段能够使用的内存。`0x000a0000 - 0x000fffff` 被作为硬件设备的映射区域，如视频显示buffer、设备固件等。以 0x100000(1MB) 为界是因为在 8086 CPU 只支持 1MB 的寻址，而在随后的 80286 中突破了该限制，但为了保持兼容性，前 1MB 依然保持该内存布局。

其中用于映射BIOS ROM的区间为 0x000f0000 - 0x000fffff 。BIOS会存放在该区域底部，一直持续到 0xfffff 。由于不同的BIOS具有不同的长度，需要准确定位到 BIOS 的起始地址是很困难的。因此规定在 0xffff0 处放一条跳转指令，跳转到BIOS的起始处。

## 加载

**`ljmp $0xf000,$0xe05b` 是一条长跳转指令，目标地址为 0xf000:0xe05b** 。

于是此时 cs 被加载为 0xf000 ，此后 base address 将遵循 real mode 下的基地址计算方法，等于 0xf000 << 4 = 0xf0000 。

在这里 `0xf000:0xe05b` 就是 BIOS 的起始地址。下一步：

```text
(gdb) si
[f000:e05b]    0xfe05b: cmpl   $0x0,%cs:0x70b8
0x0000e05b in nmi_print_seq ()


(gdb) i r cs eip
cs             0xf000   61440
eip            0xe05b   0xe05b <nmi_print_seq+219>
```

可以看到来到了 0xf000:0xe05b ，gdb显示的 `0x0000e05b in nmi_print_seq ()` 是错的，它没有考虑到 cs selector。

接下来查看 `0xf000 << 4 + 0xe05b = 0xfe05b` 附近的代码：

```text
(gdb) x/160i 0xfe05b
   0xfe05b: cmpl   $0x0,%cs:0x70b8
   0xfe062: jne    0xfd408
   0xfe066: xor    %dx,%dx
   0xfe068: mov    %dx,%ss
   0xfe06a: mov    $0x7000,%esp
   0xfe070: mov    $0xf2d7e,%edx
   0xfe076: jmp    0xfd28b
   ...
```

跳转到 0xfd28b ，其中

```text
   0xfd28b: cli
   0xfd28c: cld
```

前者保证此后的流程不会被中断，后者保证了内存将从低地址到高地址增长。后续还有**一些和硬件设备通信**的指令：

```text
   0xfd290: mov    $0x8f,%eax
   0xfd296: out    %al,$0x70
   0xfd298: in     $0x71,%al
   0xfd29a: in     $0x92,%al
   0xfd29c: or     $0x2,%al
   0xfd29e: out    %al,$0x92
```

这里将 al 中存放的值 0x8f 写入到 0x70 端口，然后从 0x71 端口读入值到 al 中，再从 0x92 端口读值到 al ，将其 bit 1 设置为 1 后重新写回 0x92。

根据 http://bochs.sourceforge.net/techspec/PORTS.LST (找不到QEMU的，用BOCHS的应该差不多)，`0x70`为`CMOS RAM index register port`，`0x71`为 `CMOS RAM data port`。由于 0x8f = 1000 1111，因此这里的行为是在禁用 NMI 的同时设置 index 为 1111。根据规范要求，在对 0x70 进行写后必须跟着对 0x71 的操作，因此这里只能跟了一个dummy read。我们不关心它的值，因此读到的值被下一条指令的结果覆盖。

接下来将 **0x92(PS/2 system control port A) 设置 bit 1为1，表示通过键盘控制器开启 Fast A20 Gate，为之后进入保护模式做准备。**

接着是**设置 GDT(Global Descriptor Table)和IDT(Interrupt Descriptor Table)**：

```text
   0xfd2a3: lidtw  %cs:0x70a8
   0xfd2a9: lgdtw  %cs:0x7064
```

这里**将 0xf000:0x70a8 中的内容作为 IDT 的 base 和 limit 设置到 IDTR 中，并将 0xf000:0x7064 作为 GDT 的 base 和 limit 设置到 GDTR 中**。

根据定义，IDTR 和 GDTR 都为 48bit 的寄存器，其中低 16 bit 为 limit(size)，高 32bit 为 base(起始地址)。打印出来如下：

```text
(gdb) x/6b 0xf7064
0xf7064:    0x37    0x00    0x70    0x70    0x0f    0x00
(gdb) x/6b 0xf70a8
0xf70a8:    0x00    0x00    0xae    0x70    0x0f    0x00
```

然后**设置 cr0 的 bit 0 为 1，正式让系统进入保护模式**。

```text
   0xfd2af: mov    %cr0,%ecx
   0xfd2b2: and    $0x1fffffff,%ecx
   0xfd2b9: or     $0x1,%ecx
   0xfd2bd: mov    %ecx,%cr0
   0xfd2c0: ljmpl  $0x8,$0xfd2c8
```

最后**通过长跳转改变 cs，开始执行保护模式代码**。切换模式后，**首先初始化各段寄存器为 0x10** ：

```text
   0xfd2c8: mov    $0x10,%ecx
   0xfd2cd: mov    %ecx,%ds
   0xfd2cf: mov    %ecx,%es
   0xfd2d1: mov    %ecx,%ss
   0xfd2d3: mov    %ecx,%fs
   0xfd2d5: mov    %ecx,%gs
   0xfd2d7: jmp    *%edx
```

跳转到 `%edx` ，即 `0xf2d7e` ......

经过一系列调用后(其实是没看懂接下来的汇编)，**BIOS完成了 激活VGA、检查插入到内存数、初始化PCI总线和其他设备等初始化操作**，比如在 VGA 初始化完成后会在屏幕上输出 "Starting SeaBIOS"。

---

在 BIOS legacy 引导中，BIOS 会搜索那些 sector 0 (MBR) 的 510-511 字节为 `0x55aa` (Magic Signature) 的存储设备，该标识表示该设备是**可引导(bootable)设备**。随后 **BIOS 将该设备的 MBR 读入到内存**。由于历史遗留问题(IBM PC 5150） **ROM BIOS 率先把第一个扇区加载到 0x7c00**，之后为了兼容都这样做了，具体可参考 https://www.glamenv-septzen.net/en/view/6 )，这个地址为 `0x00:0x7c00` 。扇区长度为 **512 byte**，因此这段地址为 `0x0000:0x7c00 - 0x0000:0x7dff` ，布局如下：

```text
                +-------------------------+   <- 0x7c00
   446 bytes    | Bootloader             |
                |                         |
                |                         |
                |                         |
                +-------------------------+
   64 bytes     | Partition Table         |
                |                         |
                +-------------------------+
   2 bytes      | Magic Signature (55 aa) |
                +-------------------------+
```

随后 **BIOS 将跳转到该地址，CPU 开始执行上面的 Bootloader 代码**。我们下个断点：

```text
(gdb) hb *0x7c00
Hardware assisted breakpoint 1 at 0x7c00
(gdb) c
Continuing.
The target architecture is assumed to be i8086
[   0:7c00] => 0x7c00 <exception_stacks+15360>: jmp    0x7c65 <exception_stacks+15461>


Breakpoint 1, 0x00007c00 in exception_stacks ()
```

可以发现 **CPU 在 BIOS 中进入了保护模式后，在执行 bootloader 前又回到了实模式**，个人猜测是为了在 BIOS 代码中能利用保护模式的特性，然后为了兼容又跳回实模式。

## 启动源码

整个启动过程分为三个部分：

1. 内核载入到物理内存，并创建最小化的运行时环境

2. 转移到内核中（平台相关）的机器码，并且初始化基本的系统功能，初始化代码是特定于系统的，一般用汇编语言编写

3. 转移到初始化代码中与平台无关的部分，一般用C语言编写，完成所有子系统的初始化，最后切换到正常工作状态。

   通过BIOS和bootloader负责第一阶段，它与具体的体系结构强相关。第二部分和硬件的相关度也很高。而第三阶段，即与系统无关的初始化阶段，内核已经载入了内存，此时的IA-32机器也需要从实模式转换为保护模式。

> 以下参考：Linux内核源代码情景分析-第十章

进入到源代码的`arch/i386/boot`目录下，引导扇区中的启动和辅助程序都在其中，主要分为三个：

- bootsect.S：引导扇区的源代码，应小于512字节
- setup.S：辅助程序
- video.S：辅助程序，用于操作显存区，用于引导过程中的屏幕显示

以及`arch/i386/boot/compressed/head.S`和`arch/i386/kernel/head.S`。

---

注释中讲到，引导扇区 bootsect 会被BIOS 例程加载到内存 `0x7c00`的位置，然后开始执行引导扇区的代码。这段代码会将其自身搬运到`0x90000`处，并跳转到那里继续执行。

然后，通过BIOS提供的读磁盘调用`int0x13`从磁盘上读入setup和内核的映象。其中setup的映象读入到地址为`0x90200`的地方，就是经过“搬运”后bootsect所在处的上方。

然后，就跳转到setup.S的代码中，作好执行内核映象的准备，主要包含：
1. 检查内核是否加载到内存中的正确位置，使用4字节的特征标记来判断, `SIG1 0xAA55`和`SIG2 0x5A5A`。
2. 确定系统内存的大小
3. 初始化显卡等设备
4. 将内核（分zImage和bzImage）移动到到内存中的某个位置，方便后续的解压缩
5. 打开A20Gate，将CPU切换到保护模式。

完成后，将跳转到`arch/i386/boot/compressed/head.S`的`startup_32`函数，当中，它主要执行以下任务：

1. 确认是否设置A20，即是否进入保护模式
2. 创建一个临时内核栈
3. 初始化`EFLAGS`标志寄存器
4. Clear BSS，用0字节填充未初始化的内核数据（BSS段），相关的区域位于 `_edata`和`_end`常数指定的位置之间。
5. 调用`arch/i386/boot/compressed/misc_32.c`中的C语言例程来解压缩内核，将未压缩的机器码写入0x100000开始的内存区。

最后进行初始化过程的最后一部分工作，控制流转移到`arch/i386/kernel/head.S`中的`startup_32`，主体包含了几个部分：

* 激活分页模式，设置一个最终的内核栈
* 用0字节填充`__bss_start`和`__end`之间的`.bss`段
* 初始化中断描述符表
* 初始化`eflags`
* 处理命令行参数
* 检测处理器类型等等

开始进入start_kernel函数，执行平台无关的任务，进行高层的初始化，通过调用内核子系统的初始化例程来实现。

![image-20220419142315471](https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96.png)

---

**内核镜像加载：**

1MB基本内存：

<img src="https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/%E4%BD%8E%E7%AB%AF1MB.png" alt="image-20220417161925619" style="zoom:50%;" />

> 错误：“用途”第二列中640KB应为64KB。参考：《操作系统真相还原》

内核映象般都是经过压缩的，压缩以后的内核映象就像是一大块数据，跟引导扇区和引导辅助程序的映象拼接在一起，成为**内核的“引导映象”**。

目录arch/i386/boot/tools中的build.c 经编译连接以后产生的可执行程序build，就是用来拼接引导映象的工具。**大小不超过508KB的引导映象称为“小映象”，文件名为zImage**；**否则就称为“大内核”，文件名为bzImage。** 由于bzImage 在基本内存中已经装载不下，所以要装载在地址为`0x100000 (1MB)`的地方。不过，**不管是zImage还是bzImage，解除压缩以后的内核映象总是放在地址为0x100000 (1MB) 的地方**。

---

**系统调用的变化：**

CPU在跳转到bootsect时仍旧处于16位实地址模式，然后在setup的执行过程中转入32位保护模式的段式寻址方式。在bootsect和setup的执行中，二者都利用BIOS提供的调用来完成一些比较大的操作，如读磁盘,取得BIOS在加电自检时搜集到的有关内存的信息等等。一旦转入内核映象本身的执行，就与BIOS分道扬镳，不再使用BIOS调用了。

### Grub引导和启动

Grub的.img引导：

grub2生成了好几个img文件，有些分布在/usr/lib/grub/i386-pc目录下，有些分布在/boot/grub2/i386-pc目录下，它们之间的关系，相信看了下文之后就会明白了。

![img](https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/Grub%20img.png)

![img](https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/Grub.png)

下图描述了各个img文件之间的关系。其中core.img是动态生成的，而其他的img则存在于/usr/lib/grub/i386-pc目录下。当然，在安装grub时，boot.img会被拷贝到/boot/grub2/i386-pc目录下。

grub把映像主要分成了三个部分：

1. 安装到MBR中的boot.img
2. 嵌入到31K空扇区的core.img
3. 存储在文件系统中的其它模块

![img](https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/Grub%E4%BD%8D%E7%BD%AE.png)

(1)boot.img

在BIOS平台下，boot.img是grub启动的第一个img文件，它被写入到MBR中或分区的boot sector中，因为boot sector的大小是512字节，所以该img文件的大小也是512字节。

boot.img唯一的作用是读取属于core.img的第一个扇区并跳转到它身上，将控制权交给该扇区的img。由于体积大小的限制，boot.img无法理解文件系统的结构，因此grub2-install将会把core.img的位置硬编码到boot.img中，这样就一定能找到core.img的位置。

(2)core.img

core.img根据diskboot.img、kernel.img和一系列的模块被grub2-mkimage程序动态创建。core.img中嵌入了足够多的功能模块以保证grub能访问/boot/grub，并且可以加载相关的模块实现相关的功能，例如加载启动菜单、加载目标操作系统的信息等，由于grub2大量使用了动态功能模块，使得core.img体积变得足够小。

core.img中包含了多个img文件的内容，包括diskboot.img/kernel.img等。

core.img的安装位置随MBR磁盘和GPT磁盘而不同。

(3)diskboot.img

如果启动设备是硬盘，即从硬盘启动时，core.img中的第一个扇区的内容就是diskboot.img。diskboo.img的作用是读取core.img中剩余的部分到内存中，并将控制权交给kernel.img，由于此时还不识别文件系统，所以将core.img的全部位置以block列表的方式编码，使得diskboot.img能够找到剩余的内容。

该img文件因为占用一个扇区，所以体积为512字节。

(4)cdboot.img

如果启动设备是光驱(cd-rom)，即从光驱启动时，core.img中的第一个扇区的的内容就是cdboo.img。它的作用和diskboot.img是一样的。

(5)pexboot.img

如果是从网络的PXE环境启动，core.img中的第一个扇区的内容就是pxeboot.img。

(6)kernel.img

kernel.img文件包含了grub的基本运行时环境：设备框架、文件句柄、环境变量、救援模式下的命令行解析器等等。很少直接使用它，因为它们已经整个嵌入到了core.img中了。**注意，kernel.img是grub的kernel，和操作系统的内核无关。**

如果细心的话，会发现kernel.img本身就占用28KB空间，但嵌入到了core.img中后，core.img文件才只有26KB大小。这是因为core.img中的kernel.img是被压缩过的。

(7)lnxboot.img

该img文件放在core.img的最前部位，使得grub像是linux的内核一样，这样core.img就可以被LILO的"image="识别。当然，这是配合LILO来使用的，但现在谁还适用LILO呢？

(8)*.mod

各种功能模块，部分模块已经嵌入到core.img中，或者会被grub自动加载，但有时也需要使用insmod命令手动加载。

### 自己的实现

**数据类型长度**

![image-20220419201019606](https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/C%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E9%95%BF%E5%BA%A6.png)

**段选择子**

![image-20220418153248579](https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90.png)

**段描述符**

<img src="https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" alt="image-20220418153346682" style="zoom:50%;" />

<img src="https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%AF%BB%E5%86%99%E5%AD%97%E6%AE%B5.png" alt="image-20220418153429601" style="zoom: 33%;" />

**全局描述符表 (GDTR)寄存器**

![image-20220419201226528](https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/GDTR%E5%AF%84%E5%AD%98%E5%99%A8.png)

GDT数据结构：

```C
struct gdt_desc{
	
};
```

加载全局描述符：

```assembly

```

打开A20地址线开关:

```assembly
in al, ox92
or la, 0000_0010B
out 0x92, al
```

开启保护模式开关：

```assembly
mov eax, cr0
or eax, 0x00000001			# PE位 设置为1
mov cr0, eax
```

远程跳转清空流水线：

```assembly
jmp dword SELECTOR_CODE: p_mode_start
```

启用分页机制，分为三步： 
1. 创建页目录表和页表 
2. 页表地址写入cr3，即PDBR  
3. 寄存器cr0的PG位置为`1`

刷新TLB等


页目录项:

<img src="https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/%E9%A1%B5%E8%A1%A8%E9%A1%B5%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="image-20220419212334074" style="zoom: 67%;" />

![image-20220419212511606](https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/PDBR.png)


![image-20220420154836933](https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/%E9%A1%B5%E7%9B%AE%E5%BD%95%E5%92%8C%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB.png)

EFLAGS寄存器：

<img src="https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/EFLAGS.png" alt="image-20220419202317128" style="zoom:50%;" />

LDT：

<img src="https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/LDT.png" alt="image-20220419200624090" style="zoom: 50%;" />

TSS段描述符:

<img src="https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/TSS.png" alt="image-20220419200748440" style="zoom: 67%;" />

TSS:

![image-20220419201627159](https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/TSS%E7%BB%93%E6%9E%84.png)





### 阶段性成功

![image-20220422201503280](https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/grub%E7%95%8C%E9%9D%A2.png)

![image-20220422201540277](https://img-bed-l.oss-cn-beijing.aliyuncs.com/pic_bed/grub%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png)



## 错误

编译时出现：

```sh
grub_head.S: Assembler messages:
grub_head.S:91: Error: invalid character '(' in mnemonic
```

问题在于没有`#include linux/linkage.h` 文件，其中对`ENTRY()`等宏进行了定义。

>  解答参考：https://www.linuxquestions.org/questions/programming-9/entry-in-s-file-results-in-parse-error-212662/





























